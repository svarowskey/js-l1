// Домашнее задание:


/**
 *  1. Для практикума из занятия 7 продумать, где можно применить замыкания.
  */
//
//
/**
 *  2. Не выполняя кода, ответить, что выведет браузер и почему:
 */
// if (!("a" in window)) {
//  var a = 1;
// }
// alert(a);
//
// Выведет 1. Потому что изначально переменной "a" в window нет. А потом она объявляется и присваивается.

//         ```
// var b = function a(x) {
//  x && a(--x);
// };
// alert(a);
// ```
//         ```
// function a(x) {
//  return x * 2;
// }
// var a;
// alert(a);
// ```
//         ```
// function b(x, y, a) {
//  arguments[2] = 10;
//  alert(a);
// }
// b(1, 2, 3);
// ```
//         ```
// function a() {
//  alert(this);
// }
// a.call(null);
//
// Думаю, что выведет window потому что передаем принудительно контекст null.
// А самый потолок у нас это window, функция его и возьмет.
//
/**
 * 3*. Программист решил сделать с помощью цикла for массив из функций, которые выводили бы цифры по порядку,
 //     т.е. хотел получить нечто вроде:
 */
//     ```
// var arr = [
//  function() { console.log(0); },
//  function() { console.log(1); },
//  function() { console.log(2); },
// ];
// arr[0](); // 0
// arr[1](); // 1
// arr[2](); // 2
// ```
// решил программист это дело так:
//     ```
// var arr = [];
// for (var i = 0; i < 3; i++) {
//  arr.push(function() { console.log(i) });
// }
// arr[0](); // 3
// arr[1](); // 3
// arr[2](); // 3
// ```
// Однако результат, который получает программист совершенно не тот, что ему нужен.
//     Исправьте ошибку программиста, покажите ему как реализовать решение используя и не используя нового
// стандарта es6.

// Первое что пришло в голову, так это записывать в цикле строкой arr.push("function() { console.log(i) }").
// Но что-то мне подсказывает, что это не так и есть какой-то хитрый метод.